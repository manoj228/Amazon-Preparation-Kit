Example 1:
k = 2
			   4
			/     \
		 6          8
	 /     \
   8          5

The kth parent of 8 and 5 is 4 which is even and therefore the answer is 8+5=13 for this example.


Example 2: 

K= 2 (means the second ancestor)

	1
      /   \
     2     3
   /  \    /
  4    5  6
 /
7
Here the output will be 7, because 2 is even. 


// Time complexity : O(N * K)
// Space complexity : O(N)

#include <bits/stdc++.h>
using namespace std;

struct Node
{	
	int data;
	Node *left, *right;
	
	Node(int _data)
	{
		data = _data;
		left = right = NULL;
	}
	
};

void findParent(map<Node *, Node *>& parent, Node *root)
{
	queue<Node *> q;
	q.push(root);
	
	while(!q.empty())
	{
		auto cur = q.front(); q.pop();
		
		if(cur -> left) 
		{
			parent[cur -> left] = cur;
			q.push(cur -> left);
		}
		
		if(cur -> right)
		{
			parent[cur -> right] = cur;
			q.push(cur -> right);
		}
	}
	
}

int findKthAncestor(map<Node *, Node *> parent, int k, Node *node)
{
	if(parent.find(node) == parent.end()) return 0;
	
	int val = node -> data;
	Node *cur = node;
	
	while(k--)
	{
		// keep on go upto reach kth parent
		cur = parent[cur];
	
		// break the loop, if we didn't have parent for cur root
		if(parent.find(cur) == parent.end()) break;
	}
	
	int res = (k <= 0 && cur->data % 2 == 0) ? val : 0;

	return res;
}

// try all possible combination
int findSumAncestor(Node *root, map<Node *, Node *> parent, int k)
{
	int skip = 1;
	queue<Node*> q;
	q.push(root);
	
	int sum = 0;
	while(!q.empty())
	{
		Node* cur = q.front(); q.pop();
	
		sum += findKthAncestor(parent, k, cur);
		
		if(cur -> left) q.push(cur->left);
		if(cur -> right) q.push(cur->right);
	}
	
	return sum;
}

int main() {
	
	Node *root = new Node(1);
	root -> left = new Node(2);
	root -> right = new Node(3);
	root -> right -> left = new Node(6);
	root -> left -> left = new Node(4);
	root -> left -> right = new Node(5);
	root -> left -> left -> left = new Node(7);

	
	map<Node *, Node *> parent;
	findParent(parent, root);
	
	
	int k = 2;
	cout << findSumAncestor(root, parent, k);
	
	return 0;
}
